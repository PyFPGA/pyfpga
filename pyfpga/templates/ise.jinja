#
# PyFPGA
# Copyright (C) 2015-2024 Rodrigo A. Melo
#
# SPDX-License-Identifier: GPL-3.0-or-later
#

set TOOL     #TOOL#
set PRESYNTH #PRESYNTH#
set PROJECT  #PROJECT#
set PART     #PART#
set FAMILY   #FAMILY#
set DEVICE   #DEVICE#
set PACKAGE  #PACKAGE#
set SPEED    #SPEED#
set TOP      #TOP#
# TASKS = prj syn par bit
set TASKS    [list #TASKS#]

set PARAMS   [list #PARAMS#]

proc fpga_files {} {
#FILES#
}

proc fpga_commands { PHASE } {
    fpga_print "setting commands for the phase '$PHASE'"
    switch $PHASE {
        "prefile" {
#PREFILE_CMDS#
        }
        "project" {
#PROJECT_CMDS#
        }
        "preflow" {
#PREFLOW_CMDS#
        }
        "postsyn" {
#POSTSYN_CMDS#
        }
        "postpar" {
#POSTPAR_CMDS#
        }
        "postbit" {
#POSTBIT_CMDS#
        }
    }
}

#
# Procedures
#

proc fpga_print { MSG } {
    global TOOL
    puts ">>> PyFPGA ($TOOL): $MSG"
}

proc fpga_create { PROJECT } {
    global TOOL
    fpga_print "creating the project '$PROJECT'"
    switch $TOOL {
        "ise"     {
            if { [ file exists $PROJECT.xise ] } { file delete $PROJECT.xise }
            project new $PROJECT.xise
        }
    }
}

proc fpga_open { PROJECT } {
    global TOOL
    fpga_print "opening the project '$PROJECT'"
    switch $TOOL {
        "ise"     { project open $PROJECT.xise }
    }
}

proc fpga_close {} {
    global TOOL
    fpga_print "closing the project"
    switch $TOOL {
        "ise"     { project close }
    }
}

proc fpga_part { PART } {
    global TOOL FAMILY DEVICE PACKAGE SPEED
    fpga_print "adding the part '$PART'"
    switch $TOOL {
        "ise"     {
            project set family  $FAMILY
            project set device  $DEVICE
            project set package $PACKAGE
            project set speed   $SPEED
        }
    }
}

proc fpga_file {FILE {LIBRARY "work"}} {
    global TOOL TOP
    set message "adding the file '$FILE'"
    if { $LIBRARY != "work" } { append message " (into the VHDL library '$LIBRARY')" }
    fpga_print $message
    regexp -nocase {\.(\w*)$} $FILE -> ext
    if { $ext == "tcl" } {
        source $FILE
        return
    }
    switch $TOOL {
        "ise" {
            if {$ext == "xcf"} {
                project set "Synthesis Constraints File" $FILE -process "Synthesize - XST"
            } elseif { $LIBRARY != "work" } {
                lib_vhdl new $LIBRARY
                xfile add $FILE -lib_vhdl $LIBRARY
            } else {
                xfile add $FILE
            }
        }
    }
}

proc fpga_include {PATH} {
    global TOOL INCLUDED
    lappend INCLUDED $PATH
    fpga_print "setting '$PATH' as a search location"
    switch $TOOL {
        "ise" {
            # Verilog Included Files are NOT added
            project set "Verilog Include Directories" \
            [join $INCLUDED "|"] -process "Synthesize - XST"
        }
    }
}

proc fpga_top { TOP } {
    global TOOL
    fpga_print "specifying the top level '$TOP'"
    switch $TOOL {
        "ise"     {
            project set top $TOP
        }
    }
}

proc fpga_params {} {
    global TOOL PARAMS
    if { [llength $PARAMS] == 0 } { return }
    fpga_print "setting generics/parameters"
    switch $TOOL {
        "ise"     {
            set assigns [list]
            foreach PARAM $PARAMS { lappend assigns [join $PARAM "="] }
            project set "Generics, Parameters" "[join $assigns]" -process "Synthesize - XST"
        }
    }
}

proc fpga_run_syn {} {
    global TOOL PRESYNTH
    fpga_print "running 'synthesis'"
    switch $TOOL {
        "ise"     {
            if { $PRESYNTH == "True" } {
                project set top_level_module_type "EDIF"
            } else {
                project clean
                process run "Synthesize"
                if { [process get "Synthesize" status] == "errors" } { exit 2 }
            }
        }
    }
}

proc fpga_run_par {} {
    global TOOL PRESYNTH
    fpga_print "running 'place and route'"
    switch $TOOL {
        "ise"     {
            process run "Translate"
            if { [process get "Translate" status] == "errors" } { exit 2 }
            process run "Map"
            if { [process get "Map" status] == "errors" } { exit 2 }
            process run "Place & Route"
            if { [process get "Place & Route" status] == "errors" } { exit 2 }
        }
    }
}

proc fpga_run_bit {} {
    global TOOL PROJECT TOP
    fpga_print "running 'bitstream generation'"
    switch $TOOL {
        "ise"     {
            process run "Generate Programming File"
            if { [process get "Generate Programming File" status] == "errors" } { exit 2 }
            catch { file rename -force $TOP.bit $PROJECT.bit }
        }
    }
}

#
# Start of the script
#

fpga_print "start of the Tcl script (interpreter $tcl_version)"

#
# Project Creation
#

if { [lsearch -exact $TASKS "prj"] >= 0 } {
    fpga_print "running the Project Creation"
    if { [catch {
        fpga_create $PROJECT
        fpga_part $PART
        fpga_commands "prefile"
        fpga_files
        fpga_top $TOP
        fpga_params
        fpga_commands "project"
        fpga_close
    } ERRMSG]} {
        puts "ERROR: there was a problem creating a New Project.\n"
        puts $ERRMSG
        exit 1
    }
}

#
# Design Flow
#

if { [lsearch -regexp $TASKS "syn|par|bit"] >= 0 } {
    fpga_print "running the Design Flow"
    if { [catch {
        fpga_open $PROJECT
        fpga_commands "preflow"
        if { [lsearch -exact $TASKS "syn"] >= 0 } {
            fpga_run_syn
            fpga_commands "postsyn"
        }
        if { [lsearch -exact $TASKS "par"] >= 0 } {
            fpga_run_par
            fpga_commands "postpar"
        }
        if { [lsearch -exact $TASKS "bit"] >= 0 } {
            fpga_run_bit
            fpga_commands "postbit"
        }
        fpga_close
    } ERRMSG]} {
        puts "ERROR: there was a problem running the Design Flow.\n"
        puts $ERRMSG
        exit 2
    }
}

#
# End of the script
#

fpga_print "end of the Tcl script"
