#
# PyFPGA
# Copyright (C) 2015-2024 Rodrigo A. Melo
#
# SPDX-License-Identifier: GPL-3.0-or-later
#

set TOOL     #TOOL#
set PRESYNTH #PRESYNTH#
set PROJECT  #PROJECT#
set PART     #PART#
set FAMILY   #FAMILY#
set DEVICE   #DEVICE#
set PACKAGE  #PACKAGE#
set SPEED    #SPEED#
set TOP      #TOP#
# TASKS = prj syn par bit
set TASKS    [list #TASKS#]

set PARAMS   [list #PARAMS#]

proc fpga_files {} {
#FILES#
}

proc fpga_commands { PHASE } {
    fpga_print "setting commands for the phase '$PHASE'"
    switch $PHASE {
        "prefile" {
#PREFILE_CMDS#
        }
        "project" {
#PROJECT_CMDS#
        }
        "preflow" {
#PREFLOW_CMDS#
        }
        "postsyn" {
#POSTSYN_CMDS#
        }
        "postpar" {
#POSTPAR_CMDS#
        }
        "postbit" {
#POSTBIT_CMDS#
        }
    }
}

#
# Procedures
#

proc fpga_print { MSG } {
    global TOOL
    puts ">>> PyFPGA ($TOOL): $MSG"
}

proc fpga_create { PROJECT } {
    global TOOL
    fpga_print "creating the project '$PROJECT'"
    switch $TOOL {
        "quartus" {
            package require ::quartus::project
            project_new $PROJECT -overwrite
            set_global_assignment -name NUM_PARALLEL_PROCESSORS ALL
        }
    }
}

proc fpga_open { PROJECT } {
    global TOOL
    fpga_print "opening the project '$PROJECT'"
    switch $TOOL {
        "quartus" {
            package require ::quartus::flow
            project_open -force $PROJECT.qpf
        }
    }
}

proc fpga_close {} {
    global TOOL
    fpga_print "closing the project"
    switch $TOOL {
        "quartus" { project_close }
    }
}

proc fpga_part { PART } {
    global TOOL FAMILY DEVICE PACKAGE SPEED
    fpga_print "adding the part '$PART'"
    switch $TOOL {
        "quartus" {
            set_global_assignment -name DEVICE $PART
        }
    }
}

proc fpga_file {FILE {LIBRARY "work"}} {
    global TOOL TOP
    set message "adding the file '$FILE'"
    if { $LIBRARY != "work" } { append message " (into the VHDL library '$LIBRARY')" }
    fpga_print $message
    regexp -nocase {\.(\w*)$} $FILE -> ext
    if { $ext == "tcl" } {
        source $FILE
        return
    }
    switch $TOOL {
        "quartus" {
            if {$ext == "v"} {
                set TYPE VERILOG_FILE
            } elseif {$ext == "sv"} {
                set TYPE SYSTEMVERILOG_FILE
            } elseif {$ext == "vhdl" || $ext == "vhd"} {
                set TYPE VHDL_FILE
            } elseif {$ext == "sdc"} {
                set TYPE SDC_FILE
            } else {
                set TYPE SOURCE_FILE
            }
            if { $LIBRARY != "work" } {
                set_global_assignment -name $TYPE $FILE -library $LIBRARY
            } else {
                set_global_assignment -name $TYPE $FILE
            }
        }
    }
}

proc fpga_include {PATH} {
    global TOOL INCLUDED
    lappend INCLUDED $PATH
    fpga_print "setting '$PATH' as a search location"
    switch $TOOL {
        "quartus" {
            # Verilog Included Files are NOT added
            foreach INCLUDE $INCLUDED {
                set_global_assignment -name SEARCH_PATH $INCLUDE
            }
        }
    }
}

proc fpga_top { TOP } {
    global TOOL
    fpga_print "specifying the top level '$TOP'"
    switch $TOOL {
        "quartus" {
            set_global_assignment -name TOP_LEVEL_ENTITY $TOP
        }
    }
}

proc fpga_params {} {
    global TOOL PARAMS
    if { [llength $PARAMS] == 0 } { return }
    fpga_print "setting generics/parameters"
    switch $TOOL {
        "quartus" {
            foreach PARAM $PARAMS {
                eval "set_parameter -name $PARAM"
            }
        }
    }
}

proc fpga_run_syn {} {
    global TOOL PRESYNTH
    fpga_print "running 'synthesis'"
    switch $TOOL {
        "quartus" {
            execute_module -tool map
        }
    }
}

proc fpga_run_par {} {
    global TOOL PRESYNTH
    fpga_print "running 'place and route'"
    switch $TOOL {
        "quartus" {
            execute_module -tool fit
            execute_module -tool sta
        }
    }
}

proc fpga_run_bit {} {
    global TOOL PROJECT TOP
    fpga_print "running 'bitstream generation'"
    switch $TOOL {
        "quartus" {
            execute_module -tool asm
        }
    }
}

#
# Start of the script
#

fpga_print "start of the Tcl script (interpreter $tcl_version)"

#
# Project Creation
#

if { [lsearch -exact $TASKS "prj"] >= 0 } {
    fpga_print "running the Project Creation"
    if { [catch {
        fpga_create $PROJECT
        fpga_part $PART
        fpga_commands "prefile"
        fpga_files
        fpga_top $TOP
        fpga_params
        fpga_commands "project"
        fpga_close
    } ERRMSG]} {
        puts "ERROR: there was a problem creating a New Project.\n"
        puts $ERRMSG
        exit 1
    }
}

#
# Design Flow
#

if { [lsearch -regexp $TASKS "syn|par|bit"] >= 0 } {
    fpga_print "running the Design Flow"
    if { [catch {
        fpga_open $PROJECT
        fpga_commands "preflow"
        if { [lsearch -exact $TASKS "syn"] >= 0 } {
            fpga_run_syn
            fpga_commands "postsyn"
        }
        if { [lsearch -exact $TASKS "par"] >= 0 } {
            fpga_run_par
            fpga_commands "postpar"
        }
        if { [lsearch -exact $TASKS "bit"] >= 0 } {
            fpga_run_bit
            fpga_commands "postbit"
        }
        fpga_close
    } ERRMSG]} {
        puts "ERROR: there was a problem running the Design Flow.\n"
        puts $ERRMSG
        exit 2
    }
}

#
# End of the script
#

fpga_print "end of the Tcl script"
