#
# PyFPGA
# Copyright (C) 2015-2024 Rodrigo A. Melo
#
# SPDX-License-Identifier: GPL-3.0-or-later
#

set TOOL     #TOOL#
set PRESYNTH #PRESYNTH#
set PROJECT  #PROJECT#
set PART     #PART#
set FAMILY   #FAMILY#
set DEVICE   #DEVICE#
set PACKAGE  #PACKAGE#
set SPEED    #SPEED#
set TOP      #TOP#
# TASKS = prj syn par bit
set TASKS    [list #TASKS#]

set PARAMS   [list #PARAMS#]

proc fpga_files {} {
#FILES#
}

proc fpga_commands { PHASE } {
    fpga_print "setting commands for the phase '$PHASE'"
    switch $PHASE {
        "prefile" {
#PREFILE_CMDS#
        }
        "project" {
#PROJECT_CMDS#
        }
        "preflow" {
#PREFLOW_CMDS#
        }
        "postsyn" {
#POSTSYN_CMDS#
        }
        "postpar" {
#POSTPAR_CMDS#
        }
        "postbit" {
#POSTBIT_CMDS#
        }
    }
}

#
# Procedures
#

proc fpga_print { MSG } {
    global TOOL
    puts ">>> PyFPGA ($TOOL): $MSG"
}

proc fpga_create { PROJECT } {
    global TOOL
    fpga_print "creating the project '$PROJECT'"
    switch $TOOL {
        "libero"  {
            if { [ file exists $PROJECT ] } { file delete -force -- $PROJECT }
            new_project -name $PROJECT -location $PROJECT -hdl {VHDL} -family {SmartFusion2}
        }
    }
}

proc fpga_open { PROJECT } {
    global TOOL
    fpga_print "opening the project '$PROJECT'"
    switch $TOOL {
        "libero"  {
            open_project $PROJECT/$PROJECT.prjx
        }
    }
}

proc fpga_close {} {
    global TOOL
    fpga_print "closing the project"
    switch $TOOL {
        "libero"  { close_project }
    }
}

proc fpga_part { PART } {
    global TOOL FAMILY DEVICE PACKAGE SPEED
    fpga_print "adding the part '$PART'"
    switch $TOOL {
        "libero"  {
            set_device -family $FAMILY -die $DEVICE -package $PACKAGE -speed $SPEED
        }
    }
}

proc fpga_file {FILE {LIBRARY "work"}} {
    global TOOL TOP
    set message "adding the file '$FILE'"
    if { $LIBRARY != "work" } { append message " (into the VHDL library '$LIBRARY')" }
    fpga_print $message
    regexp -nocase {\.(\w*)$} $FILE -> ext
    if { $ext == "tcl" } {
        source $FILE
        return
    }
    switch $TOOL {
        "libero" {
            global LIBERO_PLACE_CONSTRAINTS
            global LIBERO_OTHER_CONSTRAINTS
            if {$ext == "pdc"} {
                create_links -io_pdc $FILE
                append LIBERO_PLACE_CONSTRAINTS "-file $FILE "
            } elseif {$ext == "sdc"} {
                create_links -sdc $FILE
                append LIBERO_PLACE_CONSTRAINTS "-file $FILE "
                append LIBERO_OTHER_CONSTRAINTS "-file $FILE "
            } else {
                create_links -library $LIBRARY -hdl_source $FILE
                build_design_hierarchy
            }
        }
    }
}

proc fpga_include {PATH} {
    global TOOL INCLUDED
    lappend INCLUDED $PATH
    fpga_print "setting '$PATH' as a search location"
    switch $TOOL {
        "libero" {
            # Verilog Included Files are ALSO added
            # They must be specified after set_root (see fpga_top)
            foreach FILE [glob -nocomplain $PATH/*.vh] {
                create_links -hdl_source $FILE
            }
            build_design_hierarchy
        }
    }
}

proc fpga_top { TOP } {
    global TOOL
    fpga_print "specifying the top level '$TOP'"
    switch $TOOL {
        "libero"  {
            set_root $TOP
            # Verilog Included files
            global INCLUDED PARAMS
            set cmd "configure_tool -name {SYNTHESIZE} -params {SYNPLIFY_OPTIONS:"
            if { [info exists INCLUDED] && [llength $INCLUDED] > 0 } {
                # See <ROOT>/poc/include/libero.tcl for details
                set PATHS "../../"
                append PATHS [join $INCLUDED ";../../"]
                append cmd "set_option -include_path \"$PATHS\""
                append cmd "\n"
            }
            foreach PARAM $PARAMS {
                set assign [join $PARAM]
                append cmd "set_option -hdl_param -set \"$assign\""
                append cmd "\n"
            }
            append cmd "}"
            eval $cmd
            # Constraints
            # PDC is only used for PLACEROUTE.
            # SDC is used by ALL (SYNTHESIZE, PLACEROUTE and VERIFYTIMING).
            global LIBERO_PLACE_CONSTRAINTS
            global LIBERO_OTHER_CONSTRAINTS
            if { [info exists LIBERO_OTHER_CONSTRAINTS] } {
                set cmd "organize_tool_files -tool {SYNTHESIZE} "
                append cmd $LIBERO_OTHER_CONSTRAINTS
                append cmd "-module $TOP -input_type {constraint}"
                eval $cmd
                set cmd "organize_tool_files -tool {VERIFYTIMING} "
                append cmd $LIBERO_OTHER_CONSTRAINTS
                append cmd "-module $TOP -input_type {constraint}"
                eval $cmd
            }
            if { [info exists LIBERO_PLACE_CONSTRAINTS] } {
                set cmd "organize_tool_files -tool {PLACEROUTE} "
                append cmd $LIBERO_PLACE_CONSTRAINTS
                append cmd "-module $TOP -input_type {constraint}"
                eval $cmd
            }
        }
    }
}

proc fpga_params {} {
    global TOOL PARAMS
    if { [llength $PARAMS] == 0 } { return }
    fpga_print "setting generics/parameters"
    switch $TOOL {
        "libero"  {
            # They must be specified after set_root (see fpga_top)
        }
    }
}

proc fpga_run_syn {} {
    global TOOL PRESYNTH
    fpga_print "running 'synthesis'"
    switch $TOOL {
        "libero"  {
            run_tool -name {SYNTHESIZE}
        }
    }
}

proc fpga_run_par {} {
    global TOOL PRESYNTH
    fpga_print "running 'place and route'"
    switch $TOOL {
        "libero"  {
            run_tool -name {PLACEROUTE}
            run_tool -name {VERIFYTIMING}
        }
    }
}

proc fpga_run_bit {} {
    global TOOL PROJECT TOP
    fpga_print "running 'bitstream generation'"
    switch $TOOL {
        "libero"  {
            run_tool -name {GENERATEPROGRAMMINGFILE}
        }
    }
}

#
# Start of the script
#

fpga_print "start of the Tcl script (interpreter $tcl_version)"

#
# Project Creation
#

if { [lsearch -exact $TASKS "prj"] >= 0 } {
    fpga_print "running the Project Creation"
    if { [catch {
        fpga_create $PROJECT
        fpga_part $PART
        fpga_commands "prefile"
        fpga_files
        fpga_top $TOP
        fpga_params
        fpga_commands "project"
        fpga_close
    } ERRMSG]} {
        puts "ERROR: there was a problem creating a New Project.\n"
        puts $ERRMSG
        exit 1
    }
}

#
# Design Flow
#

if { [lsearch -regexp $TASKS "syn|par|bit"] >= 0 } {
    fpga_print "running the Design Flow"
    if { [catch {
        fpga_open $PROJECT
        fpga_commands "preflow"
        if { [lsearch -exact $TASKS "syn"] >= 0 } {
            fpga_run_syn
            fpga_commands "postsyn"
        }
        if { [lsearch -exact $TASKS "par"] >= 0 } {
            fpga_run_par
            fpga_commands "postpar"
        }
        if { [lsearch -exact $TASKS "bit"] >= 0 } {
            fpga_run_bit
            fpga_commands "postbit"
        }
        fpga_close
    } ERRMSG]} {
        puts "ERROR: there was a problem running the Design Flow.\n"
        puts $ERRMSG
        exit 2
    }
}

#
# End of the script
#

fpga_print "end of the Tcl script"
